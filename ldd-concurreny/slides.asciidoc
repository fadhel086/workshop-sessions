= Concurrency and Locking

== Concurrency

=== Overview

 * Two or more instance of a same method executed on same time
   constitutes to concurrency.

 * A method suspended in-between and another instance of it invoked
   doesn't affect the previous invocation, its again concurrency.

 * methods of program executed in any order, doesn't affect the final
   result, then they would support concurrency.

=== Types Concurrency

 * Concurrency due to multiple CPU is called true concurrency, where
   parallellism.

 * Concurrency due to interleaving of execution is called
   pseudo-concurrency.

== Multiprocessing Models

=== SMP vs AMP

* SMP 
  - A system with multiple CPUs of same architecture
  - Single kernel spans across the CPUs 

* AMP 
  - A system with multiple CPUs of different architecture.
  - two or more kernels run simultaneously  

=== SMP Issues

* A kernel driver code or function can run simultaneously on two
  different cores.

* Which may be potentially a problem if it is not taken care properly.

* 
=== Sources of Concurrency

  * SMP - two or more processors can be executing kernel code at the
    same time.

  * Sleeping - kernel code in process context can give up the
    processor by invoking the scheduler, and another process could
    start executing.

  * Pre-emption - kernel code in process context can be pre-empted by
    the scheduler and another process could be executed.

  * Interrupts - interrupts can occur at anytime causing the current
    code to be pre-empted and the interrupt handler to be executed.

  * Concurrency due to sleeping, pre-emption and interrupts comes
    under pseudo-concurrency.

=== Interrupts Revisited

------
void disable_irq(unsigned int irq);
void enble_irq(unsigned int irq);
void local_irq_disable();
void local_irq_enable();
------

.Local and System Interrupt Disable
image::figures/irq.png["Local and System Interrupt Disable",width=432]

  * Disabling of interrupts during interrupt handler execution.

=== Critical Region and Race Conditions

Critical Region:: 
Code path that accesses a shared global data.

Race Condition::
When multiple threads are in the critical region that access the same
global data, we have a race condition. It is called a race condition
because the result depends on the order of execution of the threads,
rather than the instructions in a single thread.

=== No race, with luck

`------------------`----------------------
Thread A           Thread B
------------------------------------------
fetch i (7)        
increment i (8)
writeback i (8)
-		   fetch i (8)
-		   increment i (9)
-		   writeback i (9)
------------------------------------------

=== SMP Race

`------------------`----------------------
Thread A           Thread B
------------------------------------------
fetch i (7)        fetch i (7)
increment i (8)    increment i (8)
writeback i (8)    writeback i (8)
------------------------------------------

=== Pre-emption Race

`------------------`----------------------
Thread A           Thread B
------------------------------------------
fetch i (7)        
increment i (8)    
-		   fetch i (7)
-		   increment i (8)
-		   writeback i (8)
writeback i (8)    
------------------------------------------

=== Mutex

  * When the lock is not available it puts the process to sleep.
  * Can be used to protect a shared data between process contexts.
  * Cannot be used in interrupt context because it sleeps if lock is
    not available.

  * Defining a mutex.

------
struct mutex mylock;
------

  * Defining a mutex and initializing it.

------
DEFINE_MUTEX(mylock);
------

  * Initializing a mutex at run time.

------
void mutex_init(struct mutex *lock);
------

  * Acquiring the lock.

------
void mutex_lock(struct mutex *lock);
------

  * Releasing the lock.

------
void mutex_unlock(struct mutex *lock);
------

=== Locking with Mutex (SMP case)

`------------------`----------------------
Thread A           Thread B
------------------------------------------
mutex_lock	   mutex_lock sleeps
fetch i (7)        -
increment i (8)    -
writeback i (8)    -
mutex_unlock
-		   woken up
-		   mutex_lock
-		   fetch i (8)
-		   increment i (9)
-		   writeback i (9)
-		   mutex_unlock
------------------------------------------

=== Locking with Mutex (Pre-emption case)

`------------------`----------------------
Thread A           Thread B
------------------------------------------
mutex_lock
fetch i (7)        
increment i (8)    
-		   mutex_lock sleeps
writeback i (8)	   -
mutex_unlock	   -
-		   woken up
-		   mutex_lock
-		   fetch i (8)
-		   increment i (9)
-		   writeback i (9)
-		   mutex_unlock
------------------------------------------

=== Spin Locks

  * When lock is available, disables process pre-emption, and sets a
    flag.

  * When lock is not available runs a tight loop checking the flag.

  * Can be used to protect a shared data between process contexts.

  * A variant of spin lock can also disable interrupts before
    acquiring the lock.

  * Can be used to protect a shared data between process context and
    interrupt context and between interrupt contexts.

  * Disabling interrupts only disables interrupts in the current
    processor, so interrupts can still occur in another processor.

  * Much faster that mutexes, since it does not put a process to
    sleep.

=== Using Spinlock

  * Defining a spin lock.

------
spinlock_t mylock;
------

  * Defining a spin lock and initializing it.

------
spinlock_t mylock = SPIN_LOCK_UNLOCKED;
------

  * Initializing a spin lock at run time.

------
spin_lock_init(spinlock_t *mylock);
------

  * Acquiring the lock.

------
void spin_lock(spinlock_t *lock);
------

  * Releasing the lock.

------
void spin_unlock(spinlock_t *lock);
------

  * Acquiring the lock and disabling interrupts.

------
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
------

  * Releasing lock and restoring interrupt state.

------
void spin_lock_irqrestore(spinlock_t *lock, unsigned long flags);
------

  * Code that runs with a spin lock acquired should not sleep or there
    is a possibility of dead locking.


=== Deadlocking by sleeping

`------------------`----------------------
Thread A           Thread B
------------------------------------------
spin_lock_irq	   -
sleep		   spin_lock_irq busy loops
sleep		   XX Dead Lock XX
XX Dead Lock XX 
------------------------------------------

=== What to Lock?

  * Always lock data, not the code.
  * For each shared data, make sure there is lock to protect its
    access.

=== Choosing a Locking Scheme

  * Between two process context
    - spin_lock, if it is short and does not sleep.
    - mutex, if it sleeps.

  * Between process context and interrupt context
    - spin_lock_irqsave

  * Between two interrupts
    - spin_lock_irqsave

=== Choosing a Locking Scheme Flowchart
image::figures/choose-lock.png["Choosing a Locking Scheme",width=432]

=== Deadlocks

  * Deadlock refers to a specific condition when two or more processes
    are each waiting for another to release a resource

  * Deadly Embrace

.Deadly Embrace, ABBA Deadlock
`------------------`----------------------
Thread A           Thread B
------------------------------------------
lock A		   lock B
lock B Sleep	   lock A Sleep
XX Dead Lock XX	   XX Dead Lock XX
------------------------------------------

  * Mutex - sleep for ever
  * Spinlock - spin for ever

  * Double Acquire Deadlock - can happen when a function calls another
    function that acquires the same lock. 

=== References

* https://www.slideshare.net/hemanthvenkatesh33/driver-parallelism