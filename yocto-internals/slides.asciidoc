= Internals of Yocto
Zilogic Systems <training@zilogic.com>
:data-uri:

== Things To Know

=== Package Groups

 * Poky allows to create special recipes which can build related group
   of packages.

 * Poky has several predefined packagegroups like
   packagegroup-core-boot, package-group-base etc.,

 * It is possible to create custom package group by inheriting
   packagegroup class and providing the list of packages in RDEPENDS

 * The packagegroup-core-eclipse-debug.bb available in
   meta/recipes-core/packagegroups/ is a fair example for a simple
   packagegroup.

=== Extending and Overriding Recipes

 * If already existing recipe has to be just modified for few
   parameters instead of writing the recipe again,

 * Just the newer modifications can be written in recipe file with
   extension '.bbappend' and sticking to file name as same as the main
   recipe.

 * Even if main and appended recipes are placed in different layers,
   bitbake can resolve them.

 * One example we could find is
   _packagegroup-core-tools-profile.bbappend_ in
   _meta-yocto-bsp/recipes-core/packagegroups_ just adds two packages
   to RDEPENDS, whose main recipe _packagegroup-core-tools-profile.bb_
   is available in _meta/recipes-core/packagegroups_

=== Folders Structure for Build

 * The _tmp/work_ is the folder where all the packages are unpacked and
   built.

 * For each package we would find a folder inside target architecture
   folder.

 * In our build the target architecture is _armv5e-oe-linux-gnueabi_

 * The package build directory is available in

-------
   armv5e-oe-linux-gnueabi/${PN}/${PV}-${PR}
-------

 * The source is unpacked and patched in

------
   armv5e-oe-linux-gnueabi/${PN}/${PV}-${PR}/${PN}-${PV}
------

=== Folders for Package Creation

 * The packages are compiled in _build(B)_ directory.

 * The compiled artifacts are installed in _package_ folder, then it
   is analyzed and segregated in _packages-split_ as development, doc
   and debug packages.

 * Metadata for building packages are available in _packagedata_
   folder.

=== Folders for Build Logs

 * A _temp_ folder inside the package folder would have build logs
   which can be referred on build failures.

 * We can find the details on build steps involved in building the
   package in file _log.task_order_

== Distribution

=== Customization on Distribution Level

 * If we want to different package management to be chosen, different
   init system to be chosen. These are defined to be the policy of the
   distribution.

 * For ex. Below command would configure yocto to build debian
   packages.

----
PACKAGE_CLASSES = "package_deb"
DISTRO_FEATURES_append = " sysvinit"
VIRTUAL-RUNTIME_init_manager = "sysvinit"
VIRTUAL-RUNTIME_dev_manager = "udev" 
----

=== Creating Our Own Distribution

 * By yocto convention, we may need to create a _distribution_ which has
   information about the policies to be adhered whiling building the
   individual components.

  * Distro configurations are more about how the packages are
    configured and built, rather than what packages are built.

  * Some of the distro configurations chooses how the system and
    packages has to be started in boot (sysv init or systemd)

  * Whether QT like UI components has to be compiled with X11 support
    or directfb support.

  * Certain distro features can depend on HW related
    features.

=== Creating Our Own Distribution

  * We can create a new distribution called zebian in our meta-zepto-fs
    layer

  * Inside the meta-zepto-fs/conf create a directory distro and file
    zebian.conf inside it. Write below given distro descriptions to
    it.

[source,shell]
------
$ vim meta-zepto-fs/conf/distro/zebian.conf


DISTRO = "zebian"
DISTRO_VERSION = "1.0"
PACKAGE_CLASSES = "package_deb"
------

=== Adding Our Distro to local.conf

 * Since we don't have big policies thought out for our new
   distribution, we can just choose a packaging method for our distro.

 * Can edit the conf/local.conf to build our new distro as shown below

[source,shell]
------
$ vim conf/local.conf


MACHINE = "qemuarm"
DISTRO = "zebian"
CONF_VERSION = "1"
------

 * Build the core-image-tiny image and it would get built on
   `tmp-glibc`

 * Test the new distro on the target.

== Machine

=== Need for Machine Configuration

  * _Machine_ is the target board for which the image is built.

  * The machine related configurations are available in
    conf/machine/{MACHINE}.conf file in a machine specific layer
    called as BSP layer.

  * BSP layer may also have form-factor configurations like display
    resolution, input devices to configure X11 features etc.

  * BSP layer would also have the Linux kernel compilation recipe,
    which would have default configuration for the target board.

=== Sample Machine Configuration

  * A minimal machine configuration file is given below

------
KERNEL_IMAGETYPE = "zImage"
SERIAL_CONSOLE = "115200 ttyAMA0"
MACHINE_FEATURES = "alsa bluetooth usbgadget"
PREFERRED_PROVIDER_virtual/kernel ?= "linux-yocto"
PREFERRED_VERSION_linux-yocto ?= "3.19%"
------

 * We can find a sample machine configuration file in
   _meta-yocto-bsp/conf/machine/edgerouter.conf_

=== Advantages of State Cache

 * Yocto creates hash map of the build environment of each task and
   archives the build artifact of the recipe in sstate-cache.

 * When we try to build again if the hash map generated for the task
   matched what already in exist state cache, the archived artifact is
   restored in the new build directory by setscene task.

 * We can find mostly _*setscene_ tasks in the build log.

 * We can see that for our builds, we don't have source unpacked,
   rather stages are populated from state-cache

[source,shell]
-----
ls build/tmp/work/armv5e-poky-linux-gnueabi/bash/4.3-r1/
-----

 * The state-cache creates a map for the input parameters and caches
   the out of the task using hashmap as the signature.

 * For ex if packages are first built as rpm and then we it build as
   deb, Yocto can pull data from cache until the install stage and
   just run only packaging commands for deb.
